# coding: utf-8

"""
    Metering

    MeterData API

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from metering_client.models.data_import_communication_type import DataImportCommunicationType
from metering_client.models.data_import_metering_format_type import DataImportMeteringFormatType
from metering_client.models.entity_subject_type import EntitySubjectType
from metering_client.models.metering_import_data_file_format_dto import MeteringImportDataFileFormatDto
from metering_client.models.metering_import_data_import_dto import MeteringImportDataImportDto
from metering_client.models.metering_import_statistic_dto import MeteringImportStatisticDTO
from metering_client.models.metering_import_status import MeteringImportStatus
from metering_client.models.metering_import_type import MeteringImportType
from typing import Optional, Set
from typing_extensions import Self

class MeteringImportDTO(BaseModel):
    """
    Contains the details of the metering import to determine the status and how many measurements we could process,  as well as the information how the metering import was originally created.
    """ # noqa: E501
    id: Optional[StrictStr] = Field(default=None, description="Gets or sets the unique identifier.")
    entity_type: Optional[EntitySubjectType] = Field(default=None, description="Gets or sets the type of the entity.", alias="entityType")
    created_date_time: Optional[datetime] = Field(default=None, description="Gets or sets the date and time when the entity was created.", alias="createdDateTime")
    discriminator: Optional[StrictStr] = Field(default=None, description="Gets or sets the discriminator value.")
    etag: Optional[StrictStr] = Field(default=None, description="Gets or sets the ETag value.", alias="_etag")
    require_attention: Optional[StrictBool] = Field(default=None, description="Gets a value indicating whether the entity requires attention.", alias="requireAttention")
    has_errors: Optional[StrictBool] = Field(default=None, description="Gets or sets a value indicating whether the entity has errors.", alias="hasErrors")
    has_warnings: Optional[StrictBool] = Field(default=None, description="Gets or sets a value indicating whether the entity has warnings.", alias="hasWarnings")
    is_read_only: Optional[StrictBool] = Field(default=None, description="Gets or sets a value indicating whether the entity is read-only.", alias="isReadOnly")
    organisation_id: Optional[StrictStr] = Field(default=None, description="Gets or sets the organization identifier.", alias="organisationId")
    type: Optional[MeteringImportType] = Field(default=None, description="What kind of data do we want to process in this metering import?")
    custom_file_format_id: Optional[StrictStr] = Field(default=None, description="The ID of a configured custom file format if you want to process a file in a specific format.", alias="customFileFormatId")
    data_import: Optional[MeteringImportDataImportDto] = Field(default=None, description="If the metering import was created via a data provider (mail, FTP, ...), it will contain the data  of that data provider.", alias="dataImport")
    data_file_format_settings: Optional[MeteringImportDataFileFormatDto] = Field(default=None, description="Stores the configuration values of the custom file format that was applied during processing.  This snapshot ensures that historical format settings are preserved, even if the format configuration changes later.                This is particularly useful for audit trails.", alias="dataFileFormatSettings")
    metering_format: Optional[DataImportMeteringFormatType] = Field(default=None, description="The type of metering import file that you want to process.", alias="meteringFormat")
    communication_type: Optional[DataImportCommunicationType] = Field(default=None, description="How did we receive the data for the metering import?  Mainly used for auditing purposes.", alias="communicationType")
    automatically_process: Optional[StrictBool] = Field(default=None, description="Should the metering import start processing automatically (even if there are failed values) or should  it be started manually?", alias="automaticallyProcess")
    status: Optional[MeteringImportStatus] = Field(default=None, description="The status or different phases of the metering import.")
    file_name: Optional[StrictStr] = Field(default=None, description="The filename of the file to process.  Is set to 'source.json' by default if you create a metering import with values based on JSON input.", alias="fileName")
    source: Optional[StrictStr] = Field(default=None, description="Set the source of the metering import.  Mainly used for auditing purposes.")
    interpretation_result: Optional[MeteringImportStatisticDTO] = Field(default=None, description="Statistics about how many values we could interpreted successfully.", alias="interpretationResult")
    validation_result: Optional[MeteringImportStatisticDTO] = Field(default=None, description="Statistics about how many values we could validate successfully.", alias="validationResult")
    processing_result: Optional[MeteringImportStatisticDTO] = Field(default=None, description="Statistics about how many values we could process successfully.", alias="processingResult")
    __properties: ClassVar[List[str]] = ["id", "entityType", "createdDateTime", "discriminator", "_etag", "requireAttention", "hasErrors", "hasWarnings", "isReadOnly", "organisationId", "type", "customFileFormatId", "dataImport", "dataFileFormatSettings", "meteringFormat", "communicationType", "automaticallyProcess", "status", "fileName", "source", "interpretationResult", "validationResult", "processingResult"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MeteringImportDTO from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * OpenAPI `readOnly` fields are excluded.
        """
        excluded_fields: Set[str] = set([
            "require_attention",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of data_import
        if self.data_import:
            _dict['dataImport'] = self.data_import.to_dict()
        # override the default output from pydantic by calling `to_dict()` of data_file_format_settings
        if self.data_file_format_settings:
            _dict['dataFileFormatSettings'] = self.data_file_format_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of interpretation_result
        if self.interpretation_result:
            _dict['interpretationResult'] = self.interpretation_result.to_dict()
        # override the default output from pydantic by calling `to_dict()` of validation_result
        if self.validation_result:
            _dict['validationResult'] = self.validation_result.to_dict()
        # override the default output from pydantic by calling `to_dict()` of processing_result
        if self.processing_result:
            _dict['processingResult'] = self.processing_result.to_dict()
        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if entity_type (nullable) is None
        # and model_fields_set contains the field
        if self.entity_type is None and "entity_type" in self.model_fields_set:
            _dict['entityType'] = None

        # set to None if discriminator (nullable) is None
        # and model_fields_set contains the field
        if self.discriminator is None and "discriminator" in self.model_fields_set:
            _dict['discriminator'] = None

        # set to None if etag (nullable) is None
        # and model_fields_set contains the field
        if self.etag is None and "etag" in self.model_fields_set:
            _dict['_etag'] = None

        # set to None if organisation_id (nullable) is None
        # and model_fields_set contains the field
        if self.organisation_id is None and "organisation_id" in self.model_fields_set:
            _dict['organisationId'] = None

        # set to None if type (nullable) is None
        # and model_fields_set contains the field
        if self.type is None and "type" in self.model_fields_set:
            _dict['type'] = None

        # set to None if custom_file_format_id (nullable) is None
        # and model_fields_set contains the field
        if self.custom_file_format_id is None and "custom_file_format_id" in self.model_fields_set:
            _dict['customFileFormatId'] = None

        # set to None if data_import (nullable) is None
        # and model_fields_set contains the field
        if self.data_import is None and "data_import" in self.model_fields_set:
            _dict['dataImport'] = None

        # set to None if data_file_format_settings (nullable) is None
        # and model_fields_set contains the field
        if self.data_file_format_settings is None and "data_file_format_settings" in self.model_fields_set:
            _dict['dataFileFormatSettings'] = None

        # set to None if metering_format (nullable) is None
        # and model_fields_set contains the field
        if self.metering_format is None and "metering_format" in self.model_fields_set:
            _dict['meteringFormat'] = None

        # set to None if communication_type (nullable) is None
        # and model_fields_set contains the field
        if self.communication_type is None and "communication_type" in self.model_fields_set:
            _dict['communicationType'] = None

        # set to None if status (nullable) is None
        # and model_fields_set contains the field
        if self.status is None and "status" in self.model_fields_set:
            _dict['status'] = None

        # set to None if file_name (nullable) is None
        # and model_fields_set contains the field
        if self.file_name is None and "file_name" in self.model_fields_set:
            _dict['fileName'] = None

        # set to None if source (nullable) is None
        # and model_fields_set contains the field
        if self.source is None and "source" in self.model_fields_set:
            _dict['source'] = None

        # set to None if interpretation_result (nullable) is None
        # and model_fields_set contains the field
        if self.interpretation_result is None and "interpretation_result" in self.model_fields_set:
            _dict['interpretationResult'] = None

        # set to None if validation_result (nullable) is None
        # and model_fields_set contains the field
        if self.validation_result is None and "validation_result" in self.model_fields_set:
            _dict['validationResult'] = None

        # set to None if processing_result (nullable) is None
        # and model_fields_set contains the field
        if self.processing_result is None and "processing_result" in self.model_fields_set:
            _dict['processingResult'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MeteringImportDTO from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "entityType": obj.get("entityType"),
            "createdDateTime": obj.get("createdDateTime"),
            "discriminator": obj.get("discriminator"),
            "_etag": obj.get("_etag"),
            "requireAttention": obj.get("requireAttention"),
            "hasErrors": obj.get("hasErrors"),
            "hasWarnings": obj.get("hasWarnings"),
            "isReadOnly": obj.get("isReadOnly"),
            "organisationId": obj.get("organisationId"),
            "type": obj.get("type"),
            "customFileFormatId": obj.get("customFileFormatId"),
            "dataImport": MeteringImportDataImportDto.from_dict(obj["dataImport"]) if obj.get("dataImport") is not None else None,
            "dataFileFormatSettings": MeteringImportDataFileFormatDto.from_dict(obj["dataFileFormatSettings"]) if obj.get("dataFileFormatSettings") is not None else None,
            "meteringFormat": obj.get("meteringFormat"),
            "communicationType": obj.get("communicationType"),
            "automaticallyProcess": obj.get("automaticallyProcess"),
            "status": obj.get("status"),
            "fileName": obj.get("fileName"),
            "source": obj.get("source"),
            "interpretationResult": MeteringImportStatisticDTO.from_dict(obj["interpretationResult"]) if obj.get("interpretationResult") is not None else None,
            "validationResult": MeteringImportStatisticDTO.from_dict(obj["validationResult"]) if obj.get("validationResult") is not None else None,
            "processingResult": MeteringImportStatisticDTO.from_dict(obj["processingResult"]) if obj.get("processingResult") is not None else None
        })
        return _obj


