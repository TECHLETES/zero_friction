# coding: utf-8

"""
    Metering

    MeterData API

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class MeteringImportDataFileFormatDto(BaseModel):
    """
    Stores the configuration values of the custom file format that was applied during processing.  This snapshot ensures that historical format settings are preserved, even if the format configuration changes later.                This is particularly useful for audit trails.
    """ # noqa: E501
    name: Optional[StrictStr] = Field(default=None, description="The name of the custom file format.")
    delimiter: Optional[StrictStr] = Field(default=None, description="The delimiter to parse the measurements file.")
    date_time_format: Optional[StrictStr] = Field(default=None, description="The date time format used during processing.", alias="dateTimeFormat")
    time_zone: Optional[StrictStr] = Field(default=None, description="The timezone used during processing.", alias="timeZone")
    decimal_separator: Optional[StrictStr] = Field(default=None, description="The decimal separator used during processing.", alias="decimalSeparator")
    thousands_separator: Optional[StrictStr] = Field(default=None, description="The thousands separator used during processing.", alias="thousandsSeparator")
    culture: Optional[StrictStr] = Field(default=None, description="The culture used during processing for number formatting.")
    first_line_is_header: Optional[StrictBool] = Field(default=None, description="Used for custom CSV formats which indicates if the first line was a header or not.", alias="firstLineIsHeader")
    __properties: ClassVar[List[str]] = ["name", "delimiter", "dateTimeFormat", "timeZone", "decimalSeparator", "thousandsSeparator", "culture", "firstLineIsHeader"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MeteringImportDataFileFormatDto from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if delimiter (nullable) is None
        # and model_fields_set contains the field
        if self.delimiter is None and "delimiter" in self.model_fields_set:
            _dict['delimiter'] = None

        # set to None if date_time_format (nullable) is None
        # and model_fields_set contains the field
        if self.date_time_format is None and "date_time_format" in self.model_fields_set:
            _dict['dateTimeFormat'] = None

        # set to None if time_zone (nullable) is None
        # and model_fields_set contains the field
        if self.time_zone is None and "time_zone" in self.model_fields_set:
            _dict['timeZone'] = None

        # set to None if decimal_separator (nullable) is None
        # and model_fields_set contains the field
        if self.decimal_separator is None and "decimal_separator" in self.model_fields_set:
            _dict['decimalSeparator'] = None

        # set to None if thousands_separator (nullable) is None
        # and model_fields_set contains the field
        if self.thousands_separator is None and "thousands_separator" in self.model_fields_set:
            _dict['thousandsSeparator'] = None

        # set to None if culture (nullable) is None
        # and model_fields_set contains the field
        if self.culture is None and "culture" in self.model_fields_set:
            _dict['culture'] = None

        # set to None if first_line_is_header (nullable) is None
        # and model_fields_set contains the field
        if self.first_line_is_header is None and "first_line_is_header" in self.model_fields_set:
            _dict['firstLineIsHeader'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MeteringImportDataFileFormatDto from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "delimiter": obj.get("delimiter"),
            "dateTimeFormat": obj.get("dateTimeFormat"),
            "timeZone": obj.get("timeZone"),
            "decimalSeparator": obj.get("decimalSeparator"),
            "thousandsSeparator": obj.get("thousandsSeparator"),
            "culture": obj.get("culture"),
            "firstLineIsHeader": obj.get("firstLineIsHeader")
        })
        return _obj


