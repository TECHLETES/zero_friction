# coding: utf-8

"""
    Metering

    MeterData API

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from metering_client.models.boolean_api_response_dto import BooleanApiResponseDTO
from metering_client.models.bulk_ignore_metering_issue_request import BulkIgnoreMeteringIssueRequest
from metering_client.models.bulk_resolve_metering_issue_request import BulkResolveMeteringIssueRequest
from metering_client.models.grouped_metering_issues_dto_paged_response_model_dto_api_response_dto import GroupedMeteringIssuesDTOPagedResponseModelDTOApiResponseDTO
from metering_client.models.ignore_metering_issue_request import IgnoreMeteringIssueRequest
from metering_client.models.meter_reference_paged_response_model_dto_api_response_dto import MeterReferencePagedResponseModelDTOApiResponseDTO
from metering_client.models.metering_issue_dto_api_response_dto import MeteringIssueDTOApiResponseDTO
from metering_client.models.metering_issue_dto_paged_response_model_dto_api_response_dto import MeteringIssueDTOPagedResponseModelDTOApiResponseDTO
from metering_client.models.metering_issue_error import MeteringIssueError
from metering_client.models.metering_issue_overview_count_dto_api_response_dto import MeteringIssueOverviewCountDTOApiResponseDTO
from metering_client.models.property_group_reference_paged_response_model_dto_api_response_dto import PropertyGroupReferencePagedResponseModelDTOApiResponseDTO
from metering_client.models.resolve_metering_issue_request import ResolveMeteringIssueRequest

from metering_client.api_client import ApiClient, RequestSerialized
from metering_client.api_response import ApiResponse
from metering_client.rest import RESTResponseType


class MeteringIssuesApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_meteringissues(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        meter_ids: Optional[List[StrictStr]] = None,
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        statuses: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_model_ids: Optional[List[StrictStr]] = None,
        errors: Optional[List[MeteringIssueError]] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Format - int32. Maximum number of items to return.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Property name to order results by.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MeteringIssueDTOPagedResponseModelDTOApiResponseDTO:
        """Retrieves a paged list of metering issues based on specified filter criteria.

        Retrieves a paged list of metering issues based on specified filter criteria.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param meter_ids:
        :type meter_ids: List[str]
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_end_date_time: datetime
        :param statuses:
        :type statuses: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_model_ids:
        :type meter_model_ids: List[str]
        :param errors:
        :type errors: List[MeteringIssueError]
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param limit: Format - int32. Maximum number of items to return.
        :type limit: int
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param order_by: Property name to order results by.
        :type order_by: str
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            meter_ids=meter_ids,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            statuses=statuses,
            property_group_ids=property_group_ids,
            meter_model_ids=meter_model_ids,
            errors=errors,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            limit=limit,
            name=name,
            id=id,
            order_by=order_by,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOPagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_meteringissues_with_http_info(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        meter_ids: Optional[List[StrictStr]] = None,
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        statuses: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_model_ids: Optional[List[StrictStr]] = None,
        errors: Optional[List[MeteringIssueError]] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Format - int32. Maximum number of items to return.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Property name to order results by.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MeteringIssueDTOPagedResponseModelDTOApiResponseDTO]:
        """Retrieves a paged list of metering issues based on specified filter criteria.

        Retrieves a paged list of metering issues based on specified filter criteria.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param meter_ids:
        :type meter_ids: List[str]
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_end_date_time: datetime
        :param statuses:
        :type statuses: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_model_ids:
        :type meter_model_ids: List[str]
        :param errors:
        :type errors: List[MeteringIssueError]
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param limit: Format - int32. Maximum number of items to return.
        :type limit: int
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param order_by: Property name to order results by.
        :type order_by: str
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            meter_ids=meter_ids,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            statuses=statuses,
            property_group_ids=property_group_ids,
            meter_model_ids=meter_model_ids,
            errors=errors,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            limit=limit,
            name=name,
            id=id,
            order_by=order_by,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOPagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_meteringissues_without_preload_content(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        meter_ids: Optional[List[StrictStr]] = None,
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        statuses: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_model_ids: Optional[List[StrictStr]] = None,
        errors: Optional[List[MeteringIssueError]] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Format - int32. Maximum number of items to return.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Property name to order results by.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieves a paged list of metering issues based on specified filter criteria.

        Retrieves a paged list of metering issues based on specified filter criteria.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param meter_ids:
        :type meter_ids: List[str]
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_end_date_time: datetime
        :param statuses:
        :type statuses: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_model_ids:
        :type meter_model_ids: List[str]
        :param errors:
        :type errors: List[MeteringIssueError]
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param limit: Format - int32. Maximum number of items to return.
        :type limit: int
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param order_by: Property name to order results by.
        :type order_by: str
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            meter_ids=meter_ids,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            statuses=statuses,
            property_group_ids=property_group_ids,
            meter_model_ids=meter_model_ids,
            errors=errors,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            limit=limit,
            name=name,
            id=id,
            order_by=order_by,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOPagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_meteringissues_serialize(
        self,
        zf_tuuid,
        zf_ouuid,
        meter_ids,
        noticed_start_date_time,
        noticed_end_date_time,
        statuses,
        property_group_ids,
        meter_model_ids,
        errors,
        flex_search,
        include_only_ids,
        exclude_ids,
        limit,
        name,
        id,
        order_by,
        continuation_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'MeterIds': 'multi',
            'Statuses': 'multi',
            'PropertyGroupIds': 'multi',
            'MeterModelIds': 'multi',
            'Errors': 'multi',
            'IncludeOnlyIds': 'multi',
            'ExcludeIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if meter_ids is not None:
            
            _query_params.append(('MeterIds', meter_ids))
            
        if noticed_start_date_time is not None:
            if isinstance(noticed_start_date_time, datetime):
                _query_params.append(
                    (
                        'NoticedStartDateTime',
                        noticed_start_date_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('NoticedStartDateTime', noticed_start_date_time))
            
        if noticed_end_date_time is not None:
            if isinstance(noticed_end_date_time, datetime):
                _query_params.append(
                    (
                        'NoticedEndDateTime',
                        noticed_end_date_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('NoticedEndDateTime', noticed_end_date_time))
            
        if statuses is not None:
            
            _query_params.append(('Statuses', statuses))
            
        if property_group_ids is not None:
            
            _query_params.append(('PropertyGroupIds', property_group_ids))
            
        if meter_model_ids is not None:
            
            _query_params.append(('MeterModelIds', meter_model_ids))
            
        if errors is not None:
            
            _query_params.append(('Errors', errors))
            
        if flex_search is not None:
            
            _query_params.append(('FlexSearch', flex_search))
            
        if include_only_ids is not None:
            
            _query_params.append(('IncludeOnlyIds', include_only_ids))
            
        if exclude_ids is not None:
            
            _query_params.append(('ExcludeIds', exclude_ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if name is not None:
            
            _query_params.append(('Name', name))
            
        if id is not None:
            
            _query_params.append(('Id', id))
            
        if order_by is not None:
            
            _query_params.append(('orderBy', order_by))
            
        # process the header parameters
        if continuation_token is not None:
            _header_params['continuationToken'] = continuation_token
        if zf_tuuid is not None:
            _header_params['zf-tuuid'] = zf_tuuid
        if zf_ouuid is not None:
            _header_params['zf-ouuid'] = zf_ouuid
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyQuery', 
            'apiKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/MeteringIssues',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_meteringissues_getallbymeter(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        servicelocation_ids: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_type_name: Optional[StrictStr] = None,
        meter_type_id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        received_metering_data_start: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        received_metering_data_end: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        next_expected_reading_date_start: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        next_expected_reading_date_end: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        parent_serial_number: Optional[StrictStr] = None,
        filter_by_reading_frequency: Optional[StrictBool] = None,
        reading_frequency_name: Optional[StrictStr] = None,
        reading_frequency_id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        customer_id: Optional[StrictStr] = None,
        meter_type_group: Optional[StrictStr] = None,
        meter_serial_number: Optional[StrictStr] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MeteringIssueDTOPagedResponseModelDTOApiResponseDTO:
        """Retrieves a paged list of metering issues for a specific meter.

        Retrieves a paged list of metering issues for a specific meter.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param servicelocation_ids:
        :type servicelocation_ids: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_type_name:
        :type meter_type_name: str
        :param meter_type_id: Format - int32.
        :type meter_type_id: int
        :param received_metering_data_start: Format - date-time (as date-time in RFC3339).
        :type received_metering_data_start: datetime
        :param received_metering_data_end: Format - date-time (as date-time in RFC3339).
        :type received_metering_data_end: datetime
        :param next_expected_reading_date_start: Format - date-time (as date-time in RFC3339).
        :type next_expected_reading_date_start: datetime
        :param next_expected_reading_date_end: Format - date-time (as date-time in RFC3339).
        :type next_expected_reading_date_end: datetime
        :param parent_serial_number:
        :type parent_serial_number: str
        :param filter_by_reading_frequency:
        :type filter_by_reading_frequency: bool
        :param reading_frequency_name:
        :type reading_frequency_name: str
        :param reading_frequency_id: Format - int32.
        :type reading_frequency_id: int
        :param customer_id:
        :type customer_id: str
        :param meter_type_group:
        :type meter_type_group: str
        :param meter_serial_number:
        :type meter_serial_number: str
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_getallbymeter_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            servicelocation_ids=servicelocation_ids,
            property_group_ids=property_group_ids,
            meter_type_name=meter_type_name,
            meter_type_id=meter_type_id,
            received_metering_data_start=received_metering_data_start,
            received_metering_data_end=received_metering_data_end,
            next_expected_reading_date_start=next_expected_reading_date_start,
            next_expected_reading_date_end=next_expected_reading_date_end,
            parent_serial_number=parent_serial_number,
            filter_by_reading_frequency=filter_by_reading_frequency,
            reading_frequency_name=reading_frequency_name,
            reading_frequency_id=reading_frequency_id,
            customer_id=customer_id,
            meter_type_group=meter_type_group,
            meter_serial_number=meter_serial_number,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            name=name,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOPagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_meteringissues_getallbymeter_with_http_info(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        servicelocation_ids: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_type_name: Optional[StrictStr] = None,
        meter_type_id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        received_metering_data_start: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        received_metering_data_end: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        next_expected_reading_date_start: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        next_expected_reading_date_end: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        parent_serial_number: Optional[StrictStr] = None,
        filter_by_reading_frequency: Optional[StrictBool] = None,
        reading_frequency_name: Optional[StrictStr] = None,
        reading_frequency_id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        customer_id: Optional[StrictStr] = None,
        meter_type_group: Optional[StrictStr] = None,
        meter_serial_number: Optional[StrictStr] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MeteringIssueDTOPagedResponseModelDTOApiResponseDTO]:
        """Retrieves a paged list of metering issues for a specific meter.

        Retrieves a paged list of metering issues for a specific meter.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param servicelocation_ids:
        :type servicelocation_ids: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_type_name:
        :type meter_type_name: str
        :param meter_type_id: Format - int32.
        :type meter_type_id: int
        :param received_metering_data_start: Format - date-time (as date-time in RFC3339).
        :type received_metering_data_start: datetime
        :param received_metering_data_end: Format - date-time (as date-time in RFC3339).
        :type received_metering_data_end: datetime
        :param next_expected_reading_date_start: Format - date-time (as date-time in RFC3339).
        :type next_expected_reading_date_start: datetime
        :param next_expected_reading_date_end: Format - date-time (as date-time in RFC3339).
        :type next_expected_reading_date_end: datetime
        :param parent_serial_number:
        :type parent_serial_number: str
        :param filter_by_reading_frequency:
        :type filter_by_reading_frequency: bool
        :param reading_frequency_name:
        :type reading_frequency_name: str
        :param reading_frequency_id: Format - int32.
        :type reading_frequency_id: int
        :param customer_id:
        :type customer_id: str
        :param meter_type_group:
        :type meter_type_group: str
        :param meter_serial_number:
        :type meter_serial_number: str
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_getallbymeter_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            servicelocation_ids=servicelocation_ids,
            property_group_ids=property_group_ids,
            meter_type_name=meter_type_name,
            meter_type_id=meter_type_id,
            received_metering_data_start=received_metering_data_start,
            received_metering_data_end=received_metering_data_end,
            next_expected_reading_date_start=next_expected_reading_date_start,
            next_expected_reading_date_end=next_expected_reading_date_end,
            parent_serial_number=parent_serial_number,
            filter_by_reading_frequency=filter_by_reading_frequency,
            reading_frequency_name=reading_frequency_name,
            reading_frequency_id=reading_frequency_id,
            customer_id=customer_id,
            meter_type_group=meter_type_group,
            meter_serial_number=meter_serial_number,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            name=name,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOPagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_meteringissues_getallbymeter_without_preload_content(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        servicelocation_ids: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_type_name: Optional[StrictStr] = None,
        meter_type_id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        received_metering_data_start: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        received_metering_data_end: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        next_expected_reading_date_start: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        next_expected_reading_date_end: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        parent_serial_number: Optional[StrictStr] = None,
        filter_by_reading_frequency: Optional[StrictBool] = None,
        reading_frequency_name: Optional[StrictStr] = None,
        reading_frequency_id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        customer_id: Optional[StrictStr] = None,
        meter_type_group: Optional[StrictStr] = None,
        meter_serial_number: Optional[StrictStr] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieves a paged list of metering issues for a specific meter.

        Retrieves a paged list of metering issues for a specific meter.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param servicelocation_ids:
        :type servicelocation_ids: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_type_name:
        :type meter_type_name: str
        :param meter_type_id: Format - int32.
        :type meter_type_id: int
        :param received_metering_data_start: Format - date-time (as date-time in RFC3339).
        :type received_metering_data_start: datetime
        :param received_metering_data_end: Format - date-time (as date-time in RFC3339).
        :type received_metering_data_end: datetime
        :param next_expected_reading_date_start: Format - date-time (as date-time in RFC3339).
        :type next_expected_reading_date_start: datetime
        :param next_expected_reading_date_end: Format - date-time (as date-time in RFC3339).
        :type next_expected_reading_date_end: datetime
        :param parent_serial_number:
        :type parent_serial_number: str
        :param filter_by_reading_frequency:
        :type filter_by_reading_frequency: bool
        :param reading_frequency_name:
        :type reading_frequency_name: str
        :param reading_frequency_id: Format - int32.
        :type reading_frequency_id: int
        :param customer_id:
        :type customer_id: str
        :param meter_type_group:
        :type meter_type_group: str
        :param meter_serial_number:
        :type meter_serial_number: str
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_getallbymeter_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            servicelocation_ids=servicelocation_ids,
            property_group_ids=property_group_ids,
            meter_type_name=meter_type_name,
            meter_type_id=meter_type_id,
            received_metering_data_start=received_metering_data_start,
            received_metering_data_end=received_metering_data_end,
            next_expected_reading_date_start=next_expected_reading_date_start,
            next_expected_reading_date_end=next_expected_reading_date_end,
            parent_serial_number=parent_serial_number,
            filter_by_reading_frequency=filter_by_reading_frequency,
            reading_frequency_name=reading_frequency_name,
            reading_frequency_id=reading_frequency_id,
            customer_id=customer_id,
            meter_type_group=meter_type_group,
            meter_serial_number=meter_serial_number,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            name=name,
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOPagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_meteringissues_getallbymeter_serialize(
        self,
        zf_tuuid,
        zf_ouuid,
        servicelocation_ids,
        property_group_ids,
        meter_type_name,
        meter_type_id,
        received_metering_data_start,
        received_metering_data_end,
        next_expected_reading_date_start,
        next_expected_reading_date_end,
        parent_serial_number,
        filter_by_reading_frequency,
        reading_frequency_name,
        reading_frequency_id,
        customer_id,
        meter_type_group,
        meter_serial_number,
        flex_search,
        include_only_ids,
        exclude_ids,
        name,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ServicelocationIds': 'multi',
            'PropertyGroupIds': 'multi',
            'IncludeOnlyIds': 'multi',
            'ExcludeIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if servicelocation_ids is not None:
            
            _query_params.append(('ServicelocationIds', servicelocation_ids))
            
        if property_group_ids is not None:
            
            _query_params.append(('PropertyGroupIds', property_group_ids))
            
        if meter_type_name is not None:
            
            _query_params.append(('MeterType.Name', meter_type_name))
            
        if meter_type_id is not None:
            
            _query_params.append(('MeterType.Id', meter_type_id))
            
        if received_metering_data_start is not None:
            if isinstance(received_metering_data_start, datetime):
                _query_params.append(
                    (
                        'ReceivedMeteringDataStart',
                        received_metering_data_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('ReceivedMeteringDataStart', received_metering_data_start))
            
        if received_metering_data_end is not None:
            if isinstance(received_metering_data_end, datetime):
                _query_params.append(
                    (
                        'ReceivedMeteringDataEnd',
                        received_metering_data_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('ReceivedMeteringDataEnd', received_metering_data_end))
            
        if next_expected_reading_date_start is not None:
            if isinstance(next_expected_reading_date_start, datetime):
                _query_params.append(
                    (
                        'NextExpectedReadingDateStart',
                        next_expected_reading_date_start.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('NextExpectedReadingDateStart', next_expected_reading_date_start))
            
        if next_expected_reading_date_end is not None:
            if isinstance(next_expected_reading_date_end, datetime):
                _query_params.append(
                    (
                        'NextExpectedReadingDateEnd',
                        next_expected_reading_date_end.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('NextExpectedReadingDateEnd', next_expected_reading_date_end))
            
        if parent_serial_number is not None:
            
            _query_params.append(('ParentSerialNumber', parent_serial_number))
            
        if filter_by_reading_frequency is not None:
            
            _query_params.append(('FilterByReadingFrequency', filter_by_reading_frequency))
            
        if reading_frequency_name is not None:
            
            _query_params.append(('ReadingFrequency.Name', reading_frequency_name))
            
        if reading_frequency_id is not None:
            
            _query_params.append(('ReadingFrequency.Id', reading_frequency_id))
            
        if customer_id is not None:
            
            _query_params.append(('CustomerId', customer_id))
            
        if meter_type_group is not None:
            
            _query_params.append(('MeterTypeGroup', meter_type_group))
            
        if meter_serial_number is not None:
            
            _query_params.append(('MeterSerialNumber', meter_serial_number))
            
        if flex_search is not None:
            
            _query_params.append(('FlexSearch', flex_search))
            
        if include_only_ids is not None:
            
            _query_params.append(('IncludeOnlyIds', include_only_ids))
            
        if exclude_ids is not None:
            
            _query_params.append(('ExcludeIds', exclude_ids))
            
        if name is not None:
            
            _query_params.append(('Name', name))
            
        if id is not None:
            
            _query_params.append(('Id', id))
            
        # process the header parameters
        if zf_tuuid is not None:
            _header_params['zf-tuuid'] = zf_tuuid
        if zf_ouuid is not None:
            _header_params['zf-ouuid'] = zf_ouuid
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyQuery', 
            'apiKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/MeteringIssues/getAllByMeter',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_meteringissues_grouped(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        meter_ids: Optional[List[StrictStr]] = None,
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        statuses: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_model_ids: Optional[List[StrictStr]] = None,
        errors: Optional[List[MeteringIssueError]] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Format - int32. Maximum number of items to return.")] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="Property name to group results by.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GroupedMeteringIssuesDTOPagedResponseModelDTOApiResponseDTO:
        """Retrieves a paged list of metering issues grouped by a specified property.

        Retrieves a paged list of metering issues grouped by a specified property.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param meter_ids:
        :type meter_ids: List[str]
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_end_date_time: datetime
        :param statuses:
        :type statuses: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_model_ids:
        :type meter_model_ids: List[str]
        :param errors:
        :type errors: List[MeteringIssueError]
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param limit: Format - int32. Maximum number of items to return.
        :type limit: int
        :param group_by: Property name to group results by.
        :type group_by: str
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_grouped_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            meter_ids=meter_ids,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            statuses=statuses,
            property_group_ids=property_group_ids,
            meter_model_ids=meter_model_ids,
            errors=errors,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            limit=limit,
            group_by=group_by,
            name=name,
            id=id,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GroupedMeteringIssuesDTOPagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_meteringissues_grouped_with_http_info(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        meter_ids: Optional[List[StrictStr]] = None,
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        statuses: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_model_ids: Optional[List[StrictStr]] = None,
        errors: Optional[List[MeteringIssueError]] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Format - int32. Maximum number of items to return.")] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="Property name to group results by.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GroupedMeteringIssuesDTOPagedResponseModelDTOApiResponseDTO]:
        """Retrieves a paged list of metering issues grouped by a specified property.

        Retrieves a paged list of metering issues grouped by a specified property.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param meter_ids:
        :type meter_ids: List[str]
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_end_date_time: datetime
        :param statuses:
        :type statuses: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_model_ids:
        :type meter_model_ids: List[str]
        :param errors:
        :type errors: List[MeteringIssueError]
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param limit: Format - int32. Maximum number of items to return.
        :type limit: int
        :param group_by: Property name to group results by.
        :type group_by: str
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_grouped_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            meter_ids=meter_ids,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            statuses=statuses,
            property_group_ids=property_group_ids,
            meter_model_ids=meter_model_ids,
            errors=errors,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            limit=limit,
            group_by=group_by,
            name=name,
            id=id,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GroupedMeteringIssuesDTOPagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_meteringissues_grouped_without_preload_content(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        meter_ids: Optional[List[StrictStr]] = None,
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        statuses: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_model_ids: Optional[List[StrictStr]] = None,
        errors: Optional[List[MeteringIssueError]] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Format - int32. Maximum number of items to return.")] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="Property name to group results by.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieves a paged list of metering issues grouped by a specified property.

        Retrieves a paged list of metering issues grouped by a specified property.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param meter_ids:
        :type meter_ids: List[str]
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_end_date_time: datetime
        :param statuses:
        :type statuses: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_model_ids:
        :type meter_model_ids: List[str]
        :param errors:
        :type errors: List[MeteringIssueError]
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param limit: Format - int32. Maximum number of items to return.
        :type limit: int
        :param group_by: Property name to group results by.
        :type group_by: str
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_grouped_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            meter_ids=meter_ids,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            statuses=statuses,
            property_group_ids=property_group_ids,
            meter_model_ids=meter_model_ids,
            errors=errors,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            limit=limit,
            group_by=group_by,
            name=name,
            id=id,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GroupedMeteringIssuesDTOPagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_meteringissues_grouped_serialize(
        self,
        zf_tuuid,
        zf_ouuid,
        meter_ids,
        noticed_start_date_time,
        noticed_end_date_time,
        statuses,
        property_group_ids,
        meter_model_ids,
        errors,
        flex_search,
        include_only_ids,
        exclude_ids,
        limit,
        group_by,
        name,
        id,
        continuation_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'MeterIds': 'multi',
            'Statuses': 'multi',
            'PropertyGroupIds': 'multi',
            'MeterModelIds': 'multi',
            'Errors': 'multi',
            'IncludeOnlyIds': 'multi',
            'ExcludeIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if meter_ids is not None:
            
            _query_params.append(('MeterIds', meter_ids))
            
        if noticed_start_date_time is not None:
            if isinstance(noticed_start_date_time, datetime):
                _query_params.append(
                    (
                        'NoticedStartDateTime',
                        noticed_start_date_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('NoticedStartDateTime', noticed_start_date_time))
            
        if noticed_end_date_time is not None:
            if isinstance(noticed_end_date_time, datetime):
                _query_params.append(
                    (
                        'NoticedEndDateTime',
                        noticed_end_date_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('NoticedEndDateTime', noticed_end_date_time))
            
        if statuses is not None:
            
            _query_params.append(('Statuses', statuses))
            
        if property_group_ids is not None:
            
            _query_params.append(('PropertyGroupIds', property_group_ids))
            
        if meter_model_ids is not None:
            
            _query_params.append(('MeterModelIds', meter_model_ids))
            
        if errors is not None:
            
            _query_params.append(('Errors', errors))
            
        if flex_search is not None:
            
            _query_params.append(('FlexSearch', flex_search))
            
        if include_only_ids is not None:
            
            _query_params.append(('IncludeOnlyIds', include_only_ids))
            
        if exclude_ids is not None:
            
            _query_params.append(('ExcludeIds', exclude_ids))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if group_by is not None:
            
            _query_params.append(('groupBy', group_by))
            
        if name is not None:
            
            _query_params.append(('Name', name))
            
        if id is not None:
            
            _query_params.append(('Id', id))
            
        # process the header parameters
        if continuation_token is not None:
            _header_params['continuationToken'] = continuation_token
        if zf_tuuid is not None:
            _header_params['zf-tuuid'] = zf_tuuid
        if zf_ouuid is not None:
            _header_params['zf-ouuid'] = zf_ouuid
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyQuery', 
            'apiKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/MeteringIssues/grouped',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_meteringissues_meters(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.")] = None,
        property_group_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of property group IDs to filter by.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        flex_search: Annotated[Optional[StrictStr], Field(description="Flexible search term.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MeterReferencePagedResponseModelDTOApiResponseDTO:
        """Retrieves a paged list of meters that have metering issues.

        Retrieves a paged list of meters that have metering issues.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.
        :type noticed_end_date_time: datetime
        :param property_group_ids: Array of property group IDs to filter by.
        :type property_group_ids: List[str]
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param flex_search: Flexible search term.
        :type flex_search: str
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_meters_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            property_group_ids=property_group_ids,
            name=name,
            id=id,
            flex_search=flex_search,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeterReferencePagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_meteringissues_meters_with_http_info(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.")] = None,
        property_group_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of property group IDs to filter by.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        flex_search: Annotated[Optional[StrictStr], Field(description="Flexible search term.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MeterReferencePagedResponseModelDTOApiResponseDTO]:
        """Retrieves a paged list of meters that have metering issues.

        Retrieves a paged list of meters that have metering issues.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.
        :type noticed_end_date_time: datetime
        :param property_group_ids: Array of property group IDs to filter by.
        :type property_group_ids: List[str]
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param flex_search: Flexible search term.
        :type flex_search: str
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_meters_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            property_group_ids=property_group_ids,
            name=name,
            id=id,
            flex_search=flex_search,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeterReferencePagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_meteringissues_meters_without_preload_content(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.")] = None,
        property_group_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of property group IDs to filter by.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        flex_search: Annotated[Optional[StrictStr], Field(description="Flexible search term.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieves a paged list of meters that have metering issues.

        Retrieves a paged list of meters that have metering issues.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.
        :type noticed_end_date_time: datetime
        :param property_group_ids: Array of property group IDs to filter by.
        :type property_group_ids: List[str]
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param flex_search: Flexible search term.
        :type flex_search: str
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_meters_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            property_group_ids=property_group_ids,
            name=name,
            id=id,
            flex_search=flex_search,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeterReferencePagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_meteringissues_meters_serialize(
        self,
        zf_tuuid,
        zf_ouuid,
        noticed_start_date_time,
        noticed_end_date_time,
        property_group_ids,
        name,
        id,
        flex_search,
        continuation_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'propertyGroupIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if noticed_start_date_time is not None:
            if isinstance(noticed_start_date_time, datetime):
                _query_params.append(
                    (
                        'noticedStartDateTime',
                        noticed_start_date_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('noticedStartDateTime', noticed_start_date_time))
            
        if noticed_end_date_time is not None:
            if isinstance(noticed_end_date_time, datetime):
                _query_params.append(
                    (
                        'noticedEndDateTime',
                        noticed_end_date_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('noticedEndDateTime', noticed_end_date_time))
            
        if property_group_ids is not None:
            
            _query_params.append(('propertyGroupIds', property_group_ids))
            
        if name is not None:
            
            _query_params.append(('Name', name))
            
        if id is not None:
            
            _query_params.append(('Id', id))
            
        if flex_search is not None:
            
            _query_params.append(('flexSearch', flex_search))
            
        # process the header parameters
        if continuation_token is not None:
            _header_params['continuationToken'] = continuation_token
        if zf_tuuid is not None:
            _header_params['zf-tuuid'] = zf_tuuid
        if zf_ouuid is not None:
            _header_params['zf-ouuid'] = zf_ouuid
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyQuery', 
            'apiKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/MeteringIssues/meters',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_meteringissues_overviewcount(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        meter_ids: Optional[List[StrictStr]] = None,
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        statuses: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_model_ids: Optional[List[StrictStr]] = None,
        errors: Optional[List[MeteringIssueError]] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MeteringIssueOverviewCountDTOApiResponseDTO:
        """Retrieves count statistics for metering issues based on specified filter criteria.

        Retrieves count statistics for metering issues based on specified filter criteria.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param meter_ids:
        :type meter_ids: List[str]
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_end_date_time: datetime
        :param statuses:
        :type statuses: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_model_ids:
        :type meter_model_ids: List[str]
        :param errors:
        :type errors: List[MeteringIssueError]
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_overviewcount_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            meter_ids=meter_ids,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            statuses=statuses,
            property_group_ids=property_group_ids,
            meter_model_ids=meter_model_ids,
            errors=errors,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueOverviewCountDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_meteringissues_overviewcount_with_http_info(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        meter_ids: Optional[List[StrictStr]] = None,
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        statuses: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_model_ids: Optional[List[StrictStr]] = None,
        errors: Optional[List[MeteringIssueError]] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MeteringIssueOverviewCountDTOApiResponseDTO]:
        """Retrieves count statistics for metering issues based on specified filter criteria.

        Retrieves count statistics for metering issues based on specified filter criteria.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param meter_ids:
        :type meter_ids: List[str]
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_end_date_time: datetime
        :param statuses:
        :type statuses: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_model_ids:
        :type meter_model_ids: List[str]
        :param errors:
        :type errors: List[MeteringIssueError]
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_overviewcount_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            meter_ids=meter_ids,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            statuses=statuses,
            property_group_ids=property_group_ids,
            meter_model_ids=meter_model_ids,
            errors=errors,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueOverviewCountDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_meteringissues_overviewcount_without_preload_content(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        meter_ids: Optional[List[StrictStr]] = None,
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339).")] = None,
        statuses: Optional[List[StrictStr]] = None,
        property_group_ids: Optional[List[StrictStr]] = None,
        meter_model_ids: Optional[List[StrictStr]] = None,
        errors: Optional[List[MeteringIssueError]] = None,
        flex_search: Optional[StrictStr] = None,
        include_only_ids: Optional[List[StrictStr]] = None,
        exclude_ids: Optional[List[StrictStr]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieves count statistics for metering issues based on specified filter criteria.

        Retrieves count statistics for metering issues based on specified filter criteria.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param meter_ids:
        :type meter_ids: List[str]
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339).
        :type noticed_end_date_time: datetime
        :param statuses:
        :type statuses: List[str]
        :param property_group_ids:
        :type property_group_ids: List[str]
        :param meter_model_ids:
        :type meter_model_ids: List[str]
        :param errors:
        :type errors: List[MeteringIssueError]
        :param flex_search:
        :type flex_search: str
        :param include_only_ids:
        :type include_only_ids: List[str]
        :param exclude_ids:
        :type exclude_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_overviewcount_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            meter_ids=meter_ids,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            statuses=statuses,
            property_group_ids=property_group_ids,
            meter_model_ids=meter_model_ids,
            errors=errors,
            flex_search=flex_search,
            include_only_ids=include_only_ids,
            exclude_ids=exclude_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueOverviewCountDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_meteringissues_overviewcount_serialize(
        self,
        zf_tuuid,
        zf_ouuid,
        meter_ids,
        noticed_start_date_time,
        noticed_end_date_time,
        statuses,
        property_group_ids,
        meter_model_ids,
        errors,
        flex_search,
        include_only_ids,
        exclude_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'MeterIds': 'multi',
            'Statuses': 'multi',
            'PropertyGroupIds': 'multi',
            'MeterModelIds': 'multi',
            'Errors': 'multi',
            'IncludeOnlyIds': 'multi',
            'ExcludeIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if meter_ids is not None:
            
            _query_params.append(('MeterIds', meter_ids))
            
        if noticed_start_date_time is not None:
            if isinstance(noticed_start_date_time, datetime):
                _query_params.append(
                    (
                        'NoticedStartDateTime',
                        noticed_start_date_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('NoticedStartDateTime', noticed_start_date_time))
            
        if noticed_end_date_time is not None:
            if isinstance(noticed_end_date_time, datetime):
                _query_params.append(
                    (
                        'NoticedEndDateTime',
                        noticed_end_date_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('NoticedEndDateTime', noticed_end_date_time))
            
        if statuses is not None:
            
            _query_params.append(('Statuses', statuses))
            
        if property_group_ids is not None:
            
            _query_params.append(('PropertyGroupIds', property_group_ids))
            
        if meter_model_ids is not None:
            
            _query_params.append(('MeterModelIds', meter_model_ids))
            
        if errors is not None:
            
            _query_params.append(('Errors', errors))
            
        if flex_search is not None:
            
            _query_params.append(('FlexSearch', flex_search))
            
        if include_only_ids is not None:
            
            _query_params.append(('IncludeOnlyIds', include_only_ids))
            
        if exclude_ids is not None:
            
            _query_params.append(('ExcludeIds', exclude_ids))
            
        # process the header parameters
        if zf_tuuid is not None:
            _header_params['zf-tuuid'] = zf_tuuid
        if zf_ouuid is not None:
            _header_params['zf-ouuid'] = zf_ouuid
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyQuery', 
            'apiKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/MeteringIssues/overviewcount',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_meteringissues_propertygroups(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.")] = None,
        meter_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of meter IDs to filter by.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        flex_search: Annotated[Optional[StrictStr], Field(description="Flexible search term.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PropertyGroupReferencePagedResponseModelDTOApiResponseDTO:
        """Retrieves a paged list of property groups that have metering issues.

        Retrieves a paged list of property groups that have metering issues.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.
        :type noticed_end_date_time: datetime
        :param meter_ids: Array of meter IDs to filter by.
        :type meter_ids: List[str]
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param flex_search: Flexible search term.
        :type flex_search: str
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_propertygroups_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            meter_ids=meter_ids,
            name=name,
            id=id,
            flex_search=flex_search,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PropertyGroupReferencePagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_meteringissues_propertygroups_with_http_info(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.")] = None,
        meter_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of meter IDs to filter by.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        flex_search: Annotated[Optional[StrictStr], Field(description="Flexible search term.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PropertyGroupReferencePagedResponseModelDTOApiResponseDTO]:
        """Retrieves a paged list of property groups that have metering issues.

        Retrieves a paged list of property groups that have metering issues.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.
        :type noticed_end_date_time: datetime
        :param meter_ids: Array of meter IDs to filter by.
        :type meter_ids: List[str]
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param flex_search: Flexible search term.
        :type flex_search: str
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_propertygroups_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            meter_ids=meter_ids,
            name=name,
            id=id,
            flex_search=flex_search,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PropertyGroupReferencePagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_meteringissues_propertygroups_without_preload_content(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        noticed_start_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.")] = None,
        noticed_end_date_time: Annotated[Optional[datetime], Field(description="Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.")] = None,
        meter_ids: Annotated[Optional[List[StrictStr]], Field(description="Array of meter IDs to filter by.")] = None,
        name: Optional[StrictStr] = None,
        id: Annotated[Optional[StrictInt], Field(description="Format - int32.")] = None,
        flex_search: Annotated[Optional[StrictStr], Field(description="Flexible search term.")] = None,
        continuation_token: Annotated[Optional[StrictStr], Field(description="Token for pagination.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retrieves a paged list of property groups that have metering issues.

        Retrieves a paged list of property groups that have metering issues.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param noticed_start_date_time: Format - date-time (as date-time in RFC3339). Start date and time when issues were noticed.
        :type noticed_start_date_time: datetime
        :param noticed_end_date_time: Format - date-time (as date-time in RFC3339). End date and time when issues were noticed.
        :type noticed_end_date_time: datetime
        :param meter_ids: Array of meter IDs to filter by.
        :type meter_ids: List[str]
        :param name:
        :type name: str
        :param id: Format - int32.
        :type id: int
        :param flex_search: Flexible search term.
        :type flex_search: str
        :param continuation_token: Token for pagination.
        :type continuation_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_meteringissues_propertygroups_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            noticed_start_date_time=noticed_start_date_time,
            noticed_end_date_time=noticed_end_date_time,
            meter_ids=meter_ids,
            name=name,
            id=id,
            flex_search=flex_search,
            continuation_token=continuation_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PropertyGroupReferencePagedResponseModelDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_meteringissues_propertygroups_serialize(
        self,
        zf_tuuid,
        zf_ouuid,
        noticed_start_date_time,
        noticed_end_date_time,
        meter_ids,
        name,
        id,
        flex_search,
        continuation_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'meterIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if noticed_start_date_time is not None:
            if isinstance(noticed_start_date_time, datetime):
                _query_params.append(
                    (
                        'noticedStartDateTime',
                        noticed_start_date_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('noticedStartDateTime', noticed_start_date_time))
            
        if noticed_end_date_time is not None:
            if isinstance(noticed_end_date_time, datetime):
                _query_params.append(
                    (
                        'noticedEndDateTime',
                        noticed_end_date_time.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('noticedEndDateTime', noticed_end_date_time))
            
        if meter_ids is not None:
            
            _query_params.append(('meterIds', meter_ids))
            
        if name is not None:
            
            _query_params.append(('Name', name))
            
        if id is not None:
            
            _query_params.append(('Id', id))
            
        if flex_search is not None:
            
            _query_params.append(('flexSearch', flex_search))
            
        # process the header parameters
        if continuation_token is not None:
            _header_params['continuationToken'] = continuation_token
        if zf_tuuid is not None:
            _header_params['zf-tuuid'] = zf_tuuid
        if zf_ouuid is not None:
            _header_params['zf-ouuid'] = zf_ouuid
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyQuery', 
            'apiKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/MeteringIssues/propertygroups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_meteringissues_bulk_ignore(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        bulk_ignore_metering_issue_request: Annotated[Optional[BulkIgnoreMeteringIssueRequest], Field(description="Bulk ignore details including filter criteria.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BooleanApiResponseDTO:
        """Ignores multiple metering issues in bulk.

        Ignores multiple metering issues in bulk.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param bulk_ignore_metering_issue_request: Bulk ignore details including filter criteria.
        :type bulk_ignore_metering_issue_request: BulkIgnoreMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_bulk_ignore_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            bulk_ignore_metering_issue_request=bulk_ignore_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BooleanApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_meteringissues_bulk_ignore_with_http_info(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        bulk_ignore_metering_issue_request: Annotated[Optional[BulkIgnoreMeteringIssueRequest], Field(description="Bulk ignore details including filter criteria.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BooleanApiResponseDTO]:
        """Ignores multiple metering issues in bulk.

        Ignores multiple metering issues in bulk.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param bulk_ignore_metering_issue_request: Bulk ignore details including filter criteria.
        :type bulk_ignore_metering_issue_request: BulkIgnoreMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_bulk_ignore_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            bulk_ignore_metering_issue_request=bulk_ignore_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BooleanApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_meteringissues_bulk_ignore_without_preload_content(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        bulk_ignore_metering_issue_request: Annotated[Optional[BulkIgnoreMeteringIssueRequest], Field(description="Bulk ignore details including filter criteria.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Ignores multiple metering issues in bulk.

        Ignores multiple metering issues in bulk.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param bulk_ignore_metering_issue_request: Bulk ignore details including filter criteria.
        :type bulk_ignore_metering_issue_request: BulkIgnoreMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_bulk_ignore_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            bulk_ignore_metering_issue_request=bulk_ignore_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BooleanApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_meteringissues_bulk_ignore_serialize(
        self,
        zf_tuuid,
        zf_ouuid,
        bulk_ignore_metering_issue_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if zf_tuuid is not None:
            _header_params['zf-tuuid'] = zf_tuuid
        if zf_ouuid is not None:
            _header_params['zf-ouuid'] = zf_ouuid
        # process the form parameters
        # process the body parameter
        if bulk_ignore_metering_issue_request is not None:
            _body_params = bulk_ignore_metering_issue_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'text/json', 
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyQuery', 
            'apiKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/MeteringIssues/bulk/ignore',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_meteringissues_bulk_resolve(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        bulk_resolve_metering_issue_request: Annotated[Optional[BulkResolveMeteringIssueRequest], Field(description="Bulk resolution details including filter criteria.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BooleanApiResponseDTO:
        """Resolves multiple metering issues in bulk.

        Resolves multiple metering issues in bulk.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param bulk_resolve_metering_issue_request: Bulk resolution details including filter criteria.
        :type bulk_resolve_metering_issue_request: BulkResolveMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_bulk_resolve_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            bulk_resolve_metering_issue_request=bulk_resolve_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BooleanApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_meteringissues_bulk_resolve_with_http_info(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        bulk_resolve_metering_issue_request: Annotated[Optional[BulkResolveMeteringIssueRequest], Field(description="Bulk resolution details including filter criteria.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BooleanApiResponseDTO]:
        """Resolves multiple metering issues in bulk.

        Resolves multiple metering issues in bulk.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param bulk_resolve_metering_issue_request: Bulk resolution details including filter criteria.
        :type bulk_resolve_metering_issue_request: BulkResolveMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_bulk_resolve_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            bulk_resolve_metering_issue_request=bulk_resolve_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BooleanApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_meteringissues_bulk_resolve_without_preload_content(
        self,
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        bulk_resolve_metering_issue_request: Annotated[Optional[BulkResolveMeteringIssueRequest], Field(description="Bulk resolution details including filter criteria.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Resolves multiple metering issues in bulk.

        Resolves multiple metering issues in bulk.

        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param bulk_resolve_metering_issue_request: Bulk resolution details including filter criteria.
        :type bulk_resolve_metering_issue_request: BulkResolveMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_bulk_resolve_serialize(
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            bulk_resolve_metering_issue_request=bulk_resolve_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BooleanApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_meteringissues_bulk_resolve_serialize(
        self,
        zf_tuuid,
        zf_ouuid,
        bulk_resolve_metering_issue_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if zf_tuuid is not None:
            _header_params['zf-tuuid'] = zf_tuuid
        if zf_ouuid is not None:
            _header_params['zf-ouuid'] = zf_ouuid
        # process the form parameters
        # process the body parameter
        if bulk_resolve_metering_issue_request is not None:
            _body_params = bulk_resolve_metering_issue_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'text/json', 
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyQuery', 
            'apiKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/MeteringIssues/bulk/resolve',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_meteringissues_issueid_ignore(
        self,
        issue_id: Annotated[StrictStr, Field(description="ID of the metering issue to ignore.")],
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        ignore_metering_issue_request: Annotated[Optional[IgnoreMeteringIssueRequest], Field(description="Ignore details.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MeteringIssueDTOApiResponseDTO:
        """Ignores a specific metering issue.

        Ignores a specific metering issue.

        :param issue_id: ID of the metering issue to ignore. (required)
        :type issue_id: str
        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param ignore_metering_issue_request: Ignore details.
        :type ignore_metering_issue_request: IgnoreMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_issueid_ignore_serialize(
            issue_id=issue_id,
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            ignore_metering_issue_request=ignore_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_meteringissues_issueid_ignore_with_http_info(
        self,
        issue_id: Annotated[StrictStr, Field(description="ID of the metering issue to ignore.")],
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        ignore_metering_issue_request: Annotated[Optional[IgnoreMeteringIssueRequest], Field(description="Ignore details.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MeteringIssueDTOApiResponseDTO]:
        """Ignores a specific metering issue.

        Ignores a specific metering issue.

        :param issue_id: ID of the metering issue to ignore. (required)
        :type issue_id: str
        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param ignore_metering_issue_request: Ignore details.
        :type ignore_metering_issue_request: IgnoreMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_issueid_ignore_serialize(
            issue_id=issue_id,
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            ignore_metering_issue_request=ignore_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_meteringissues_issueid_ignore_without_preload_content(
        self,
        issue_id: Annotated[StrictStr, Field(description="ID of the metering issue to ignore.")],
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        ignore_metering_issue_request: Annotated[Optional[IgnoreMeteringIssueRequest], Field(description="Ignore details.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Ignores a specific metering issue.

        Ignores a specific metering issue.

        :param issue_id: ID of the metering issue to ignore. (required)
        :type issue_id: str
        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param ignore_metering_issue_request: Ignore details.
        :type ignore_metering_issue_request: IgnoreMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_issueid_ignore_serialize(
            issue_id=issue_id,
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            ignore_metering_issue_request=ignore_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_meteringissues_issueid_ignore_serialize(
        self,
        issue_id,
        zf_tuuid,
        zf_ouuid,
        ignore_metering_issue_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if issue_id is not None:
            _path_params['issueId'] = issue_id
        # process the query parameters
        # process the header parameters
        if zf_tuuid is not None:
            _header_params['zf-tuuid'] = zf_tuuid
        if zf_ouuid is not None:
            _header_params['zf-ouuid'] = zf_ouuid
        # process the form parameters
        # process the body parameter
        if ignore_metering_issue_request is not None:
            _body_params = ignore_metering_issue_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'text/json', 
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyQuery', 
            'apiKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/MeteringIssues/{issueId}/ignore',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def post_meteringissues_issueid_resolve(
        self,
        issue_id: Annotated[StrictStr, Field(description="ID of the metering issue to resolve.")],
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        resolve_metering_issue_request: Annotated[Optional[ResolveMeteringIssueRequest], Field(description="Resolution details.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MeteringIssueDTOApiResponseDTO:
        """Resolves a specific metering issue.

        Resolves a specific metering issue.

        :param issue_id: ID of the metering issue to resolve. (required)
        :type issue_id: str
        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param resolve_metering_issue_request: Resolution details.
        :type resolve_metering_issue_request: ResolveMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_issueid_resolve_serialize(
            issue_id=issue_id,
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            resolve_metering_issue_request=resolve_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def post_meteringissues_issueid_resolve_with_http_info(
        self,
        issue_id: Annotated[StrictStr, Field(description="ID of the metering issue to resolve.")],
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        resolve_metering_issue_request: Annotated[Optional[ResolveMeteringIssueRequest], Field(description="Resolution details.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MeteringIssueDTOApiResponseDTO]:
        """Resolves a specific metering issue.

        Resolves a specific metering issue.

        :param issue_id: ID of the metering issue to resolve. (required)
        :type issue_id: str
        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param resolve_metering_issue_request: Resolution details.
        :type resolve_metering_issue_request: ResolveMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_issueid_resolve_serialize(
            issue_id=issue_id,
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            resolve_metering_issue_request=resolve_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def post_meteringissues_issueid_resolve_without_preload_content(
        self,
        issue_id: Annotated[StrictStr, Field(description="ID of the metering issue to resolve.")],
        zf_tuuid: Annotated[StrictStr, Field(description="Format - uuid. Tenant ID")],
        zf_ouuid: Annotated[StrictStr, Field(description="Format - uuid. Organisation ID")],
        resolve_metering_issue_request: Annotated[Optional[ResolveMeteringIssueRequest], Field(description="Resolution details.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Resolves a specific metering issue.

        Resolves a specific metering issue.

        :param issue_id: ID of the metering issue to resolve. (required)
        :type issue_id: str
        :param zf_tuuid: Format - uuid. Tenant ID (required)
        :type zf_tuuid: str
        :param zf_ouuid: Format - uuid. Organisation ID (required)
        :type zf_ouuid: str
        :param resolve_metering_issue_request: Resolution details.
        :type resolve_metering_issue_request: ResolveMeteringIssueRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._post_meteringissues_issueid_resolve_serialize(
            issue_id=issue_id,
            zf_tuuid=zf_tuuid,
            zf_ouuid=zf_ouuid,
            resolve_metering_issue_request=resolve_metering_issue_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MeteringIssueDTOApiResponseDTO",
            '400': "ApiResponseDTO",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _post_meteringissues_issueid_resolve_serialize(
        self,
        issue_id,
        zf_tuuid,
        zf_ouuid,
        resolve_metering_issue_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if issue_id is not None:
            _path_params['issueId'] = issue_id
        # process the query parameters
        # process the header parameters
        if zf_tuuid is not None:
            _header_params['zf-tuuid'] = zf_tuuid
        if zf_ouuid is not None:
            _header_params['zf-ouuid'] = zf_ouuid
        # process the form parameters
        # process the body parameter
        if resolve_metering_issue_request is not None:
            _body_params = resolve_metering_issue_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'text/json', 
                        'application/*+json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'apiKeyQuery', 
            'apiKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/MeteringIssues/{issueId}/resolve',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


