# coding: utf-8

"""
    Billing

    Billing API

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from billing_client.models.incoming_mutation_grouped_details_dto import IncomingMutationGroupedDetailsDTO
from typing import Optional, Set
from typing_extensions import Self

class IncomingBankingTransactionInsightsDTO(BaseModel):
    """
    Provides detailed insights and analytics about an incoming banking transaction.  This DTO contains aggregated information about mutations grouped by status, type, and payment method.
    """ # noqa: E501
    incoming_banking_transaction_id: Optional[StrictStr] = Field(default=None, description="The unique identifier of the incoming banking transaction.", alias="incomingBankingTransactionId")
    identification: Optional[StrictStr] = Field(default=None, description="The identification number of the transaction file.")
    opening_balance: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The opening balance of the account at the start of the transaction period.", alias="openingBalance")
    closing_balance: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The closing balance of the account at the end of the transaction period.", alias="closingBalance")
    balance_difference: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The difference between the closing and opening balances.", alias="balanceDifference")
    opening_balance_date: Optional[datetime] = Field(default=None, description="The date and time of the opening balance.", alias="openingBalanceDate")
    closing_balance_date: Optional[datetime] = Field(default=None, description="The date and time of the closing balance.", alias="closingBalanceDate")
    status_details: Optional[Dict[str, IncomingMutationGroupedDetailsDTO]] = Field(default=None, description="Details of mutations grouped by their status.", alias="statusDetails")
    mutation_type_details: Optional[Dict[str, IncomingMutationGroupedDetailsDTO]] = Field(default=None, description="Details of mutations grouped by their type.", alias="mutationTypeDetails")
    payment_method_details: Optional[Dict[str, IncomingMutationGroupedDetailsDTO]] = Field(default=None, description="Details of mutations grouped by their payment method.", alias="paymentMethodDetails")
    __properties: ClassVar[List[str]] = ["incomingBankingTransactionId", "identification", "openingBalance", "closingBalance", "balanceDifference", "openingBalanceDate", "closingBalanceDate", "statusDetails", "mutationTypeDetails", "paymentMethodDetails"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of IncomingBankingTransactionInsightsDTO from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each value in status_details (dict)
        _field_dict = {}
        if self.status_details:
            for _key_status_details in self.status_details:
                if self.status_details[_key_status_details]:
                    _field_dict[_key_status_details] = self.status_details[_key_status_details].to_dict()
            _dict['statusDetails'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in mutation_type_details (dict)
        _field_dict = {}
        if self.mutation_type_details:
            for _key_mutation_type_details in self.mutation_type_details:
                if self.mutation_type_details[_key_mutation_type_details]:
                    _field_dict[_key_mutation_type_details] = self.mutation_type_details[_key_mutation_type_details].to_dict()
            _dict['mutationTypeDetails'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in payment_method_details (dict)
        _field_dict = {}
        if self.payment_method_details:
            for _key_payment_method_details in self.payment_method_details:
                if self.payment_method_details[_key_payment_method_details]:
                    _field_dict[_key_payment_method_details] = self.payment_method_details[_key_payment_method_details].to_dict()
            _dict['paymentMethodDetails'] = _field_dict
        # set to None if incoming_banking_transaction_id (nullable) is None
        # and model_fields_set contains the field
        if self.incoming_banking_transaction_id is None and "incoming_banking_transaction_id" in self.model_fields_set:
            _dict['incomingBankingTransactionId'] = None

        # set to None if identification (nullable) is None
        # and model_fields_set contains the field
        if self.identification is None and "identification" in self.model_fields_set:
            _dict['identification'] = None

        # set to None if opening_balance (nullable) is None
        # and model_fields_set contains the field
        if self.opening_balance is None and "opening_balance" in self.model_fields_set:
            _dict['openingBalance'] = None

        # set to None if closing_balance (nullable) is None
        # and model_fields_set contains the field
        if self.closing_balance is None and "closing_balance" in self.model_fields_set:
            _dict['closingBalance'] = None

        # set to None if balance_difference (nullable) is None
        # and model_fields_set contains the field
        if self.balance_difference is None and "balance_difference" in self.model_fields_set:
            _dict['balanceDifference'] = None

        # set to None if status_details (nullable) is None
        # and model_fields_set contains the field
        if self.status_details is None and "status_details" in self.model_fields_set:
            _dict['statusDetails'] = None

        # set to None if mutation_type_details (nullable) is None
        # and model_fields_set contains the field
        if self.mutation_type_details is None and "mutation_type_details" in self.model_fields_set:
            _dict['mutationTypeDetails'] = None

        # set to None if payment_method_details (nullable) is None
        # and model_fields_set contains the field
        if self.payment_method_details is None and "payment_method_details" in self.model_fields_set:
            _dict['paymentMethodDetails'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of IncomingBankingTransactionInsightsDTO from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "incomingBankingTransactionId": obj.get("incomingBankingTransactionId"),
            "identification": obj.get("identification"),
            "openingBalance": obj.get("openingBalance"),
            "closingBalance": obj.get("closingBalance"),
            "balanceDifference": obj.get("balanceDifference"),
            "openingBalanceDate": obj.get("openingBalanceDate"),
            "closingBalanceDate": obj.get("closingBalanceDate"),
            "statusDetails": dict(
                (_k, IncomingMutationGroupedDetailsDTO.from_dict(_v))
                for _k, _v in obj["statusDetails"].items()
            )
            if obj.get("statusDetails") is not None
            else None,
            "mutationTypeDetails": dict(
                (_k, IncomingMutationGroupedDetailsDTO.from_dict(_v))
                for _k, _v in obj["mutationTypeDetails"].items()
            )
            if obj.get("mutationTypeDetails") is not None
            else None,
            "paymentMethodDetails": dict(
                (_k, IncomingMutationGroupedDetailsDTO.from_dict(_v))
                for _k, _v in obj["paymentMethodDetails"].items()
            )
            if obj.get("paymentMethodDetails") is not None
            else None
        })
        return _obj


